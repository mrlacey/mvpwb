---
uti: com.xamarin.workbook
platforms:
- iOS
packages:
- id: Xamarin.Forms
  version: 2.3.2.127
---

# Fun with BoxView (iOS)

In one sense, `BoxView` is the least important view in all of Xamarin.Forms. It’s only a box of a particular color and size, and it doesn’t do anything. But `BoxView` is more versatile than it first seems, and it’s valuable in Xamarin.Forms because it’s the closest thing the environment has to a vector graphics object. BoxView provides a means to do some rudimentary graphics in a Xamarin.Forms application.

Experimenting with `BoxView` is also a good way to learn about the intricacies of Xamarin.Forms layout. Prepare to see a lot of `HorizontalOptions` and `VerticalOptions` in this workbook.

This Workbook has been prepared for Xamarin.Forms by adding the Xamarin.Forms NuGet package. The following C# Script file creates references to rudimentary graphics in a Xamarin.Forms application. Xamarin.Forms assemblies, and performs initialization for iOS.

```csharp
#load "FormsInit-iOS.csx"
```

At the conclusion of the C# Script file, a variable named `page` is availale of type `ContentPage`. A `Padding` property has been set to avoid overwriting the iOS status bar. The following two `using` directives are standard for a simple Xamarin.Forms application:

```csharp
using System;
using Xamarin.Forms;
```

Instantiate a `BoxView` and set it to the `Content` property of the `page`:

```csharp
var firstBoxView = new BoxView();
page.Content = firstBoxView;
```

The default color of the `BoxView` is transparent, however. The `Color` property must be set to make it visible. One convenient color is Color.Accent, which is intended to be visible against a light or dark background, but almost any color will do here:

```csharp
firstBoxView.Color = Color.Accent;
```

The `BoxView` fills the page, except for the area indicated by the `Padding` property, which protects the iOS status bar.

When a `BoxView` (or any other element) is set to the `Content` property of a `ContentPage`, it is said to be *constrained* by the dimensions of the page, and that’s the size the `BoxView` becomes.

The default `HorizontalOptions` and `VerticalOptions` properties of the `BoxView` are `LayoutOptions.Fill`. If these properties are set to any other values, the `BoxView` becomes unconstained in that dimension, and the BoxView is forced to determine its own size:

```csharp
firstBoxView.HorizontalOptions = LayoutOptions.Center;
firstBoxView.VerticalOptions = LayoutOptions.Center;
```

The `BoxView` becomes 40 units square. Try various combinations of the `LayoutOptions` static fields (`Start`, `Center`, `End`, and `Fill`) for various effects.

What are the settings of `HorizontalOptions` and `VerticalOptions` that position the `BoxView` at the far right with a 40-unit width but extending the whole height of the page?

The 40-unit default width and height of the `BoxView` is established by the [`BoxView` source code](https://github.com/xamarin/Xamarin.Forms/blob/master/Xamarin.Forms.Core/BoxView.cs "BoxView source code"). To override those values, set the `WidthRequest` and `HeightRequest` properties to something other than their default values of –1. If you set one or the other property to a very small number, you can effectively draw a line. For example, this code draws a 150-unit long horizontal line that is positioned at the left of the page and is vertically center on the page:

```csharp
firstBoxView.WidthRequest = 150;
firstBoxView.HeightRequest = 3;
firstBoxView.HorizontalOptions = LayoutOptions.Start;
firstBoxView.VerticalOptions = LayoutOptions.Center;
```

If both the `HorizontalOptions` and `VerticalOptions` properties are set to `LayoutOptions.Start`, the `Margin` property can govern where the line begins relative to the upper-left corner of the page:

```csharp
firstBoxView.HorizontalOptions = LayoutOptions.Start;
firstBoxView.VerticalOptions = LayoutOptions.Start;
firstBoxView.Margin = new Thickness(100, 50, 0, 0);
```

Normally the `BoxView` is aligned with the horizontal and vertical sides of the page, but the setting the `Rotation` property rotates the `BoxView` by that many degrees in a clockwise direction:

```csharp
firstBoxView.AnchorX = 0;   // make rotation relative to left end of line
firstBoxView.Rotation = 30;
```

However, the approach of setting a `BoxView` to the `Content` property of a `ContentPage` is inherently limited because only one element can be set to that property, and generally a page contains multiple elements. The following code sets a `ScrollView` containing a `StackLayout` to the `Content` property of the page:

```csharp
var scrollView = new ScrollView();
var stackLayout = new StackLayout();
scrollView.Content = stackLayout;
page.Content = scrollView;
```

This configuration will allow adding multiple items to the `StackLayout` that will appear in a vertical list.

Now a `BoxView` can be added to that `StackLayout`:

```csharp
var plainBoxView = new BoxView
{
    Color = Color.Accent
};
stackLayout.Children.Add(plainBoxView);
```

A vertical `StackLayout` constrains the width of the `BoxView`, which means that the `BoxView` stretches across the entire width of the `StackLayout`. But the `StackLayout` leaves the height of the `BoxView` unconstrained, which means that the BoxView itself determines its height, which is 40 units. As usual, you can unconstrain the width by setting the `HorizontalOptions` to something other than `LayoutOptions.Fill`:

```csharp
plainBoxView.HorizontalOptions = LayoutOptions.Center;
```

The `VerticalOptions` setting doesn’t affect the `BoxView` in a vertical `StackLayout`, but you can still set `WidthRequest` and `HeightRequest` to change the `BoxView` size. (Try it!)

## Underling Text

One practical use of `BoxView` is an underline for text. Here’s a `Grid` containing a `Label` with some text:

```csharp
var label = new Label
{
    Text = "Underlined Text",
    FontSize = 24,
    FontFamily = "Snell Roundhand"
};

var labelGrid = new Grid();
labelGrid.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });
labelGrid.Children.Add(label);
stackLayout.Children.Add(labelGrid);
```

This `Grid` occupies the entire width of the parent `StackLayout`. (To visually see that, set the `BackgroundColor` of the `Grid`.) The `Label` is implicitly in the first column of the `Grid`, and that first column has a width of `Auto`, meaning that it’s the same width as the `Label`. (Try setting the `BackgroundColor` of the `Label` to see that.) Make the `Grid` the width of the `Label` and center it in the `StackLayout` using:

```csharp
labelGrid.HorizontalOptions = LayoutOptions.Center;
```

Now add a `BoxView` to the `Grid` with a small `HeightRequest` to make it appear as a vertical line, and vertically positioned at the bottom of the `Grid`:

```csharp
labelGrid.Children.Add(new BoxView
{
    Color = Color.Black,
    HeightRequest = 1,
    VerticalOptions = LayoutOptions.End
});
```

Because no row or column was specified, the `BoxView` occupies the same cell as the `Label`.

## Drawing an Empty Box

Use a single-cell `Grid` for a parent to multiple `BoxView` elements that combine to form a simple image of some sort. The first step is to give this `Grid` a specific size.

TODO: Rename grid1 —> ?

```csharp
var grid1 = new Grid
{
    WidthRequest = 100,
    HeightRequest = 100
};
stackLayout.Children.Add(grid1);
```

The following code creates four `BoxView` elements, and adds them to the `Grid` as well as stores them in an array. The even items (indices 0 and 2) are given a `Width` of 3 units, while the odd items (indices 1 and 3) are give a `Height` of 3 units:

```csharp
BoxView[] sides = new BoxView[4];

for (int i = 0; i < 4; i++)
{
    var side = new BoxView
    {
        Color = Color.Accent,
        WidthRequest = i % 2 == 0 ? 3 : -1,
        HeightRequest = i % 2 == 1 ? 3 : -1
    }; 
    grid1.Children.Add(side);
    sides[i] = side;
}
```

However, all four `BoxView` elements fill the `Grid` because they all have default settings of their `HorizontalOptions` and `VerticalOptions` properties. Setting them to these values cause each `BoxView` to be aligned against a side of the `Grid`:

```csharp
sides[0].HorizontalOptions = LayoutOptions.Start;
sides[1].VerticalOptions = LayoutOptions.Start;
sides[2].HorizontalOptions = LayoutOptions.End;
sides[3].VerticalOptions = LayoutOptions.End;
```

Now the `Grid` can be made 100 units wide by setting its `HorizontalOptions` property

```csharp
grid1.HorizontalOptions = LayoutOptions.Center;
```

```csharp
var circleStack = new StackLayout
{
    Orientation = StackOrientation.Horizontal,
    Spacing = 0,
    HeightRequest = 100,
    HorizontalOptions = LayoutOptions.Center
};
stackLayout.Children.Add(circleStack);
```

```csharp
for (int i = 0; i < 100; i++)
{
    BoxView circleBox = new BoxView
    {
        Color = Color.FromHsla(i / 100.0, 1.0, 0.5, 1.0),
        WidthRequest = 1,
        HeightRequest = 100 * Math.Sin(Math.Acos((i - 50) / 50.0)),
        VerticalOptions = LayoutOptions.Center
    };
    circleStack.Children.Add(circleBox);

}
```

## Drawing a Circle

If you want to draw an unfilled circle, it’s a whole different strategy of piecing together tiny rotated BoxView elements used as short lines that comprise the circle. Here’s a single-cell `Grid` containing 60 `BoxView` elements, each of which is 6 degrees of the complete circle:

```csharp
const double radius = 50;
const double thickness = 3;
const int count = 60;

Grid emptyCircleGrid = new Grid
{
    WidthRequest = 2 * radius,
    HeightRequest = 2 * radius,
    HorizontalOptions = LayoutOptions.Center
};
stackLayout.Children.Add(emptyCircleGrid);

for (int i = 0; i < count; i++)
{
    emptyCircleGrid.Children.Add(new BoxView
    {
        Color = Color.Accent,
        HeightRequest = thickness,
        WidthRequest = 2 * Math.PI * radius / count,
        HorizontalOptions = LayoutOptions.Center,
        VerticalOptions = LayoutOptions.Start
    });
}
```

All 60 `BoxView` elements are horizontally centered at the top of the `Grid`. They need to be rotated into position to form a circle.

The easy part is the rotation angle. If there are 60 `BoxView` elements, the rotation angle for each successive `BoxView` increases in increments of 360 degrees divided by 60: 0 degrees, 6 degrees, 12, 18, and so forth up to 354 degrees.

The tricky part is that each `BoxView` needs to be rotated around the center of the circle, and that center is 47 units (`radius` minus `thickness`) *below* each `BoxView`.

The `AnchorX` and `AnchorY` propertiesKelvin\*1831 define the center around which rotation occurs, but these values are relative to the element. Both `AnchorX` and `AnchorY` have default values of 0.5, which means that by default, rotation is around the center of the element itself.

The default AnchorX setting is fine, but AnchorY needs to be set `radius` units from the top of the element, relative to the height of the element itself, or `radius / thickness`:

```csharp
for (int i = 0; i < count; i++)
{
    View view = emptyCircleGrid.Children[i];
    view.AnchorY = radius / thickness;
    view.Rotation = i * 360 / count;
}
```

How low does `count` have to be before it stops looking like a circle? And what happens when you set `count` to a fairly low number like 5 or 6?

TK

## Rotating Spokes

```csharp
const double radius = 100;
const double thickness = 3;
static readonly Point center = new Point(radius, radius);
const int spokeCount = 24;

var spokeLayout = new AbsoluteLayout
{
    WidthRequest = 2 * radius,
    HeightRequest = 2 * radius,
    HorizontalOptions = LayoutOptions.Center
};
stackLayout.Children.Add(spokeLayout);

for (int i = 0; i < spokeCount; i++)
{
    double degrees = 360 * i / spokeCount;
    double radians = Math.PI * degrees / 180;
    double x = center.X + radius / 2 * Math.Cos(radians);
    double y = center.Y + radius / 2 * Math.Sin(radians);
    Point boxViewCenter = new Point(x, y);

    var boxView = new BoxView
    {
        Color = Color.Accent,
        WidthRequest = radius,
        HeightRequest = thickness,
        Rotation = degrees 

    };
    Size boxViewSize = new Size(radius, thickness);
    Point boxViewOrigin = boxViewCenter - boxViewSize * 0.5;


    spokeLayout.Children.Add(boxView, new Rectangle(boxViewOrigin, boxViewSize));

}
```

```csharp
new Animation((t) => spokeLayout.Rotation = 360 * t).Commit(page, "spokeRotate", length: 5000, repeat: () => true);
```

```csharp
double[] rotation = new double[spokeCount];

for (int i = 0; i < spokeCount; i++)
{
    View view = spokeLayout.Children[i];
    rotation[i] = view.Rotation;
}

new Animation((t) =>
{
    for (int i = 0; i < spokeCount; i++)
    {
        View view = spokeLayout.Children[i];
        view.Rotation = rotation[i] + 360 * t;
    }
}).Commit(page, "spokesRotate", length: 5000, repeat: () => true);
```


---
uti: com.xamarin.workbook
platforms:
- iOS
packages:
- id: Xamarin.Forms
  version: 2.3.2.127
---

# Mandelbrot Touch (iOS)

In 1980, while working at an IBM research center, Polish born mathematician Benoit Mandelbrot saw a crude computer-generated image that had published two years earlier:

![From the public domain image on the Wikipedia article on the Mandelbot Set.](Mandelbrot.png "The Mandelbrot Set")

Mandelbrot had already coined the word *fractal* five years earlier to describe complex self-similar geometries, but he eventually did so much work connected with the mathematics bethind this particular image that it became known as the *Mandelbrot set*.

The program described in this workbook draws a more detailed rendition of the Mandelbrot set with color. Using touch, you can pan the image or use a pinch gesture to zoom in or out.

## The Mandelbrot Math

The Mandelbrot set is graphed on the complex plane, where each point is a complex number of the form:

c = x \+ y*i*

The real part (x) is represented by the horizontal axis, and the imaginary part (y) by the vertical axis.

To calculation the Mandebrot set, begin by taking any complex point on this plane and call it c. Initialize the complex number z to zero:

c = x \+ y*i*

z = 0

Now perform the following recursive calculation:

z ← z² \+ c

The result will either diverge to infinity or it will not. If z does not diverge to infinity, then c is is said to be a member of the Mandelbrot set. Otherwise it is not a member. This operation must be repeated for every point of interest in the plane.

Sometime the recursive calculation must be performed very many times to determine if z  diverges or not. If the absolute value of z ever becomes 2 or greater, than the values will eventually diverge to infinity. But otherwise, the only way to determine if a point is a member or not is to continue performing the recursive calculations.

For that reason, Mandelbrot calculations are notoriously computation-intensive and are best performed in secondary threads of execution.

It has become common for Mandelbrot sets to incorporate color. Points that are members of the Mandelbrot set are colored black. Points that are not members are given a color based on the number of iterations required to determine that the calculation will diverge to infinity.

The program described here uses a bitmap to render the Mandelbrot set. The recursive calculation is performed on the complex point that corresponds to each pixel of the bitmap.

## The Code Support

This workbook includes several C# Script files for support:

```csharp
#load "MandelbrotModel.csx"
#load "BmpMaker.csx"
#load "FormsInit-iOS.csx"
```

The MandelbrotModel.csx file contains a class named `MandelbrotModel` with a single asynchronous method named `CalculateAsync` that performs the basic Mandelbort calculation for an array of points. The results are later used to create a bitmap, so several parameters to this method indicate the pixel size of this bitmap, and the complex coordinates corresponding to that array of pixels.

The `CalculateAsync` method makes use of a structure named `Complex` that is defined in the Complex.csx file, and returns an object of type `Task<BitmapInfo>`.

The `BitmapInfo` class (defined in BitmapInfo.csx) contains sufficient information to create a bitmap to render the results of the Mandelbrot calculation — a pixel width and height, and an array of integers indicating the number of iterations required for each point to determine the point was not a member of the Mandelbrot set, or –1 if the point is a member.

The BmpMaker.csx file contains a class name `BmpMaker` (“bitmap maker”) that creates a Xamarin.Forms `ImageSource` object using the BMP file format.

More information on these classes (and the Mandelbrot calculation itself) can be found in [Chapter 13 (Bitmaps)](https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/summaries/chapter13 "Chapter 13. Bitmaps")  and [Chapter 20 (Async and File I/O)](https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/summaries/chapter20 "Chapter 20. Async and File I/O") of the book *[Creating Mobile Apps with Xamairn.Forms](https://developer.xamarin.com/guides/xamarin-forms/creating-mobile-apps-xamarin-forms/ "Creating Mobile Apps with Xamarin.Forms")*.

Finally, the FormsInit-iOS.csx file contains startup code for a Xamarin.Forms program running under iOS. At the conclusion of that code, a variable named `page` is available of type `ContentPage`.

## Building the User Interface

Just a few standard `using` directives are required:

```csharp
using System;
using System.Threading;
using Xamarin.Forms;
```

Set some `Padding`on the page that guards against overwriting the iOS status bar:

```csharp
page.Padding = new Thickness(5, Device.OnPlatform(20, 5, 5), 5, 10);
```

The main layout is a three-row `Grid`. The top row is allocated all the space not required by the other two rows:

```csharp
var grid = new Grid();
grid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(1, GridUnitType.Star) });
grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
grid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
page.Content = grid;
```

The top row is the bitmap, which in Xamarin.Forms is displayed by an `Image` element. However, to obtain gesture input that is affects the `Image` element, the `Image` element is made a child of a `ContentView` named `gestureContainer`:

```csharp
var image = new Image();
var gestureContainer = new ContentView();
gestureContainer.Content = image;
gestureContainer.IsClippedToBounds = true;
grid.Children.Add(gestureContainer, 0, 0);
```

See the guide on [Xamarin.Forms gestures](https://developer.xamarin.com/guides/xamarin-forms/user-interface/gestures/ "Gestures") for more details about using such a container.

The second row of the Grid contains a ProgressBar to show the progress of each complete Mandelbrot calculation:

```csharp
var progressBar = new ProgressBar();
grid.Children.Add(progressBar, 0, 1);
```

When you execute that code, you should see the ProgressBar appear as a dim gray line near the bottom of the screen.

This `ProgressBar` must be updated in the `CalculateAsync` method of the `MandelbrotModel` class. Because this method runs in a secondary thread of execution, the safest way of updating the `ProgressBar` involves a class provided specifically for this purpose named `Progress`:

```csharp
var progressReporter = new Progress<double>(progress => progressBar.Progress = progress);
```

A lambda function passed to the `Progress` constructor updates the `ProgressBar` from an argument to the function.

## The Mandelbrot Calculation

Next are some constants and variables that define the Mandelbrot image. Taken together, the `baseSize`, `center`, and `magnification` arguments indicate that the initial Mandelbrot image will have real coordinates ranging from –2.0 (on the left edge of the bitmap) to 0.5 (on the right edge), and imaginary coordinates from 1.25 on the top to –1.25 on the bottom. However, the actual range in either the horizontal or vertical direction will be larger than that depending on the aspect ratio of the bitmap.

The `center` variable will change when the image is panned; the `magnification` variable changes as the image is zoomed.

```csharp
static readonly Size baseSize = new Size(2.5, 2.5);
Complex center = new Complex(-0.75, 0);
double magnification = 1.0;
int iterations = 256;
double pixelsPerUnit = 0;
var mandelbrotModel = new MandelbrotModel();
```

The `iterations` variable indicates the number of recursive calculations performed before the point is assumed to be in the Mandelbrot Set. The `pixelsPerUnit` variable is calculated based on the pixel size of the bitmap. Finally, the `MandelbrotModel` class is instantiated to perform the actual calculation. (Recall that this class is defined in the MandelbrotModel.csx C# script file.)

The `CreateNewImage` method is the core

```csharp
async void CreateNewImage(CancellationToken cancelToken)
{
    double aspect = image.Width / image.Height;
    double width = baseSize.Width / magnification * (aspect > 1 ? aspect : 1);
    double height = baseSize.Height / magnification / (aspect < 1 ? aspect : 1);
    pixelsPerUnit = image.Width / width;
    BitmapInfo bitmapInfo = null;

    try
    {
        bitmapInfo = await mandelbrotModel.CalculateAsync(center, width, height, 
                                                          (int)image.Width, (int)image.Height,
                                                          iterations, progressReporter, cancelToken);
    }
    catch (OperationCanceledException)
    {
        return;
    }

    BmpMaker bmpMaker = new BmpMaker(bitmapInfo.PixelWidth, bitmapInfo.PixelHeight);

    int index = 0;
    for (int row = 0; row < bitmapInfo.PixelHeight; row++)
    {
        for (int col = 0; col < bitmapInfo.PixelWidth; col++)
        {
            int iterationCount = bitmapInfo.IterationCounts[index++];

            // In the Mandelbrot set: Color black.
            if (iterationCount == -1)
            {
                bmpMaker.SetPixel(row, col, 0, 0, 0);
            }
            // Not in the Mandelbrot set: Pick a color based on count.
            else
            {
                bmpMaker.SetPixel(row, col, Color.FromHsla(iterationCount / 64.0 % 1.0, 1.0, 0.5));
            }
        }
    }
    image.Source = bmpMaker.Generate();
    image.TranslationX = 0;
    image.TranslationY = 0;
    image.Scale = 1;
}
```

```csharp
CancellationTokenSource cancelTokenSource = new CancellationTokenSource();
CreateNewImage(cancelTokenSource.Token);
```

```csharp
image.SizeChanged += (sender, args) =>
{
    if (gestureContainer.Width > 0 && gestureContainer.Height > 0)
    {
        cancelTokenSource = new CancellationTokenSource();
        CreateNewImage(cancelTokenSource.Token);
    }
};
```

## Panning the Image

```csharp
// Avoid multiple gesture recognizers when code is re-executed
for (int i = 0; i < gestureContainer.GestureRecognizers.Count; i++)
{
    if (gestureContainer.GestureRecognizers[i] is PanGestureRecognizer)
    {
        gestureContainer.GestureRecognizers.RemoveAt(i);
        i--;
    }
}

var pan = new PanGestureRecognizer();
gestureContainer.GestureRecognizers.Add(pan);

double translationX = 0;
double translationY = 0;

pan.PanUpdated += (sender, args) =>
{
    switch (args.StatusType)
    {
        case GestureStatus.Started:
            if (cancelTokenSource != null)
            {
                cancelTokenSource.Cancel();
            }

            translationX = image.TranslationX;
            translationY = image.TranslationY;
            break;

        case GestureStatus.Running:
            image.TranslationX = translationX + args.TotalX;
            image.TranslationY = translationY + args.TotalY;
            break;

        case GestureStatus.Completed:
            center = new Complex(center.Real - image.TranslationX / pixelsPerUnit,
                                    center.Imaginary + image.TranslationY / pixelsPerUnit);

            cancelTokenSource = new CancellationTokenSource();
            CreateNewImage(cancelTokenSource.Token);
            break;
    }
};
```

Pinching the Image

```csharp
// Avoid multiple gesture recognizers when code is re-executed
for (int i = 0; i < gestureContainer.GestureRecognizers.Count; i++)
{
    if (gestureContainer.GestureRecognizers[i] is PinchGestureRecognizer)
    {
        gestureContainer.GestureRecognizers.RemoveAt(i);
        i--;
    }
}

var pinch = new PinchGestureRecognizer();
gestureContainer.GestureRecognizers.Add(pinch);

double scale = 1;

pinch.PinchUpdated += (sender, args) =>
{
    switch (args.Status)
    {
        case GestureStatus.Started:
            if (cancelTokenSource != null)
            {
                cancelTokenSource.Cancel();
            }

            scale = image.Scale;
            break;

        case GestureStatus.Running:
            image.Scale += (args.Scale -1) * scale;
            break;

        case GestureStatus.Completed:
            magnification *= image.Scale;
            cancelTokenSource = new CancellationTokenSource();
            CreateNewImage(cancelTokenSource.Token);
            break;
    }
};
```

## Adjusting the Iterations

```csharp
var stepperStack = new StackLayout
{
    Orientation = StackOrientation.Horizontal
};
var labelStack = new StackLayout
{
    Orientation = StackOrientation.Horizontal,
    VerticalOptions = LayoutOptions.Center
}
stepperStack.Children.Add(labelStack);

labelStack.Children.Add(new Label
{
    Text = "Iterations = 2",
    FontSize = Device.GetNamedSize(NamedSize.Medium, typeof(Label))
});
Label exponentLabel = new Label
{
    Text = "7",
    FontSize = Device.GetNamedSize(NamedSize.Micro, typeof(Label))
}
labelStack.Children.Add(exponentLabel);

var iterationsStepper = new Stepper
{
    Value = 7,
    VerticalOptions = LayoutOptions.Center
};

iterationsStepper.ValueChanged += (sender, args)
{
    int exponent = (int)(sender as Stepper).Value;
    exponentLabel.Text = exponent.ToString();
    iterations = (int)Math.Pow(2, exponent);
};

```
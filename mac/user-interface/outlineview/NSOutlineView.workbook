---
uti: com.xamarin.workbook
platforms:
- MacMobile
---

# Working with Outline Views

#### Using a Outline View in a Xamarin.Mac Application

This workbook will cover the steps required to add a Outline View (`NSOutlineView`) to a Xamarin.Mac app's User Interface directly from C# code without using a Xcode's Interface Builder `.storyboard` or `.xib` file.

## Creating the Outline View

`NSOutlineView` is a native cocoa control for displaying tree data. Start by creating an instance and set its `Frame` property to a reasonable size. It will be autosized via an owning `NSClipView`:

```csharp
// Get the parent window's frame
var frame = MainWindow.ContentView.Frame;

// Make a new outline view and have it fill the parent window
NSOutlineView outlineView = new NSOutlineView () {
	Frame = frame
};
```

## Adding the Outline View Columns

Every `NSOutlineView` must have at least one column for its delegate to be called. Since Outline Views are based on Table Views (`NSTableView`), a Table Column is created and added to the Outline:

```csharp
// Create the required column and add it to the outline
NSTableColumn column = new NSTableColumn ("Values");
outlineView.AddColumn (column);
```

Additionally, the `OutlineTableColumn` property of the Outline View must be set or the arrows showing children/expansion will not be drawn:

```csharp
// Specify the outline column
outlineView.OutlineTableColumn = column;
```

## Adding the Clip View

A `NSOutlineView` expects to be hosted inside an `NSClipView`. The following code creates the required Clip View and adds the Outline View to it:

```csharp
// Create the required clipping view and set it to
// resize both horizontally and vertically as the
// parent window resizes.
NSClipView clipView = new NSClipView (frame) {
		AutoresizingMask = NSViewResizingMask.HeightSizable | NSViewResizingMask.WidthSizable
};

// Attach the outline view to the clip view
clipView.DocumentView = outlineView;
```

Next, add the Clip View to the Window’s Content View to display the Outline:

```csharp
// Attach the clip view to the main window
MainWindow.ContentView = clipView;
```

## Creating Sample Data for the Outline

Currently, this Outline View isn’t very exciting without any data. A `Node` class will be a created to provide a simple tree-based data structure. Because `NSOutlineViewDataSource` returns a `NSObject`, the `Node` class will inherit from it:

```csharp
// Custom class to define the data for the outline view.
class Node : NSObject
{
    // The name for the node.
	public string Name { get; private set; }

    // A collection of child nodes.
	List<Node> Children;

    // Initalize a new node with the given name
    // and create storage for any child nodes.
	public Node (string name)
	{
		Name = name;
		Children = new List<Node> ();
	}

    // Create a new child node of a given name
    // and add it to the collection of child nodes.
	public Node AddChild (string name)
	{
		Node n = new Node (name);
		Children.Add (n);
		return n;
	}

    // Return the child for a given index
	public Node GetChild (int index)
	{
		return Children [index];
	}

    // Get the curent number of children
	public int ChildCount => Children.Count;

    // The node is a leaf node if it has no children
	public bool IsLeaf => ChildCount == 0;
}
```

The following method will create the example data that will be displayed in the Outline View:

```csharp
// Populate an example set of parent and child nodes.
Node CreateExampleTree ()
{
    // Create a base node to hold the data
	Node parentNode = new Node ("");

    // Generate a set of parent and child nodes
	for (int i = 0 ; i < 5 ; ++i) {
		Node n = parentNode.AddChild ("Parent: " + i);
		for (int j = 0; j < 3 ; ++j)
			n.AddChild ("Child: " + j);
	}

    // Return the completed sample data
	return parentNode;
}
```

## Adding Data to the Ouline View

`NSOutlineView` uses a two classes, a `DataSource` and `Delegate`, to determine what data to display. `NSOutlineView` can be used in two different “modes”: *Cell Based* or *View Based*.

Different overrides apply to each of these modes, such that overriding some of the Cell Based methods will prevent the View Based methods from being called. According to Apple, Cell Based Outlines have been deprecated and View Based Outlines should be used for all modern macOS development.

`OutlineViewDelegate` defines the view for an individual element of the tree. The item passed in is generated by `OutlineViewDataSource`.

### Creating the Elements for the Outline

For every element, the Outline View calls its `Delegate` to provide the individual Cells. By calling `MakeView` method of the Outline View with an identifier, existing views can be recycled, which can improve performance:

```csharp
class OutlineViewDelegate : NSOutlineViewDelegate
{
    // Provide an ID for each cell so it can be reused
	const string identifer = "myCellIdentifier";

    // Generate a new view to act as the cell for each table row and column
	public override NSView GetView (NSOutlineView outlineView, NSTableColumn tableColumn, NSObject item)
	{
        // Ask the table view to reuse a cell
		NSTextField view = (NSTextField)outlineView.MakeView (identifer, this);

        // Was a reusable cell available?
		if (view == null) {
            // No, create a new cell
			view = new NSTextField () {
				Identifier = identifer,
				Bordered = false,
				Selectable = false,
				Editable = false
			};
		}

        // Populate the cell
		view.StringValue = ((Node)item).Name;

        // Return the fully populated cell
		return view;
	}
}
```

### Defining the Tree Structure

The `OutlineViewDataSource` defines the structures of the tree,  how many elements are in the Outline and if those elements are expandable. The `GetChild` method analyzes  the `NSObject` that is passed to `GetView` method of the `OutlineViewDelegate`. If the item passed in is `null`, then Cocoa is refering to the root the the tree:

```csharp
class OutlineViewDataSource : NSOutlineViewDataSource
{
    // Storage for the outline view data.
	Node parentNode;

    // Create a new data source from the given tree data.
	public OutlineViewDataSource (Node node)
	{
		parentNode = node;
	}

    // Return the number of children for the given element in the outline.
	public override nint GetChildrenCount (NSOutlineView outlineView, NSObject item)
	{
        // If the passed in element is null, use the parent node.
		item = item == null ? parentNode : item;

        // Return the number of children
		return ((Node)item).ChildCount;
	}

    // Return the given child for the given element and index.
	public override NSObject GetChild (NSOutlineView outlineView, nint childIndex, NSObject item)
	{
        // If the passed in element is null, use the parent node.
		item = item == null ? parentNode : item;

        // Return the requested child
		return ((Node)item).GetChild ((int)childIndex);
	}

    // If the current item has children, it is expandable.
	public override bool ItemExpandable (NSOutlineView outlineView, NSObject item)
	{
        // If the passed in element is null, use the parent node.
		item = item == null ? parentNode : item;

        // Return the expandable state
		return !((Node)item).IsLeaf;
	}
}
```

### Displaying the Data

Hooking up the `Delegate` and `DataSource` to the `NSOutlineView` is the final step. This will populate the tree with the sample data:

```csharp
// Attach the data source and delegate to populate the outline
outlineView.Delegate = new OutlineViewDelegate ();
outlineView.DataSource = new OutlineViewDataSource (CreateExampleTree ());
```